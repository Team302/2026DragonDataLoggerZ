plugins {
    id "java"
    id 'application'
    id 'com.gradleup.shadow' version '8.3.5'
    id "edu.wpi.first.GradleRIO" version "2026.2.1"
    id 'edu.wpi.first.WpilibTools' version '2.1.0'
}

application {
    mainClass = 'pi.logger.PiLogger'
}

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(17)
    }
}

tasks.withType(JavaCompile).configureEach {
    options.release = 17
}

repositories {
    mavenCentral()
    maven { url = 'https://frcmaven.wpi.edu/artifactory/release/' }
}

wpilibTools.deps.wpilibVersion = wpi.versions.wpilibVersion.get()

def nativeConfigName = 'wpilibNatives'
def nativeConfig = configurations.create(nativeConfigName)

def nativeTasks = wpilibTools.createExtractionTasks {
    configurationName = nativeConfigName
}

nativeTasks.addToSourceSetResources(sourceSets.main)
nativeConfig.dependencies.add wpilibTools.deps.wpilib("wpimath")
nativeConfig.dependencies.add wpilibTools.deps.wpilib("wpinet")
nativeConfig.dependencies.add wpilibTools.deps.wpilib("wpiutil")
nativeConfig.dependencies.add wpilibTools.deps.wpilib("ntcore")
nativeConfig.dependencies.add wpilibTools.deps.wpilib("cscore")



dependencies {

    implementation wpilibTools.deps.wpilibJava("wpiutil")
    implementation wpilibTools.deps.wpilibJava("wpimath")
    implementation wpilibTools.deps.wpilibJava("wpinet")
    implementation wpilibTools.deps.wpilibJava("ntcore")
    implementation wpilibTools.deps.wpilibJava("cscore")
    implementation wpilibTools.deps.wpilibJava("cameraserver")
    implementation "edu.wpi.first.wpiunits:wpiunits-java:2026.2.1"

    // Add JNI libraries for runtime
    runtimeOnly wpilibTools.deps.wpilib("wpimath")
    runtimeOnly wpilibTools.deps.wpilib("wpinet")
    runtimeOnly wpilibTools.deps.wpilib("wpiutil")
    runtimeOnly wpilibTools.deps.wpilib("ntcore")
    runtimeOnly wpilibTools.deps.wpilib("cscore")

    implementation group: "com.fasterxml.jackson.core", name: "jackson-annotations", version: wpi.versions.jacksonVersion.get()
    implementation group: "com.fasterxml.jackson.core", name: "jackson-core", version: wpi.versions.jacksonVersion.get()
    implementation group: "com.fasterxml.jackson.core", name: "jackson-databind", version: wpi.versions.jacksonVersion.get()

    implementation group: "org.ejml", name: "ejml-simple", version: wpi.versions.ejmlVersion.get()
    implementation group: "us.hebi.quickbuf", name: "quickbuf-runtime", version: wpi.versions.quickbufVersion.get();
}

jar {
    manifest {
        attributes 'Main-Class': 'pi.logger.PiLogger'
    }
}

shadowJar {
    archiveBaseName = "PiLogger"
    archiveVersion = ""
    exclude("module-info.class")
    archiveClassifier.set(wpilibTools.currentPlatform.platformName)
    manifest {
        attributes 'Main-Class': 'pi.logger.PiLogger'
    }
    // Merge service files for proper loading
    mergeServiceFiles()
}

// Make shadowJar include the extracted natives as resources
// nativeTasks is already added to sourceSets.main.resources, so no explicit dependency needed

assemble.dependsOn shadowJar

configurations {
    arm64Natives {
        // Make this configuration use the same repositories as regular dependencies
        canBeConsumed = false
        canBeResolved = true
    }
}

dependencies {
    arm64Natives wpi.java.deps.wpilibJniRelease(wpi.platforms.linuxarm64)
    arm64Natives wpi.java.vendor.jniRelease(wpi.platforms.linuxarm64)
}

wrapper {
    gradleVersion = '8.11'
}

task shadowJarArm64(type: com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar) {
    archiveBaseName = "PiLogger"
    archiveVersion = ""
    archiveClassifier.set("linuxarm64-cross")
    from sourceSets.main.output
    configurations = [project.configurations.runtimeClasspath]
    exclude("module-info.class")
    // Exclude Windows native libraries from the jar
    exclude {
        def path = it.path.toLowerCase()
        path.contains("windows/") || path.contains("win32/") || path.contains("x86-64/") ||
        path.contains("windowsx86-64.zip") || path.contains("win32.zip") || path.contains("x86-64.zip") ||
        path.endsWith(".so.debug")
    }
    manifest {
        attributes 'Main-Class': 'pi.logger.PiLogger'
    }
    mergeServiceFiles()
    // Extract ARM64 natives from ZIP files and include them
    from(project.configurations.arm64Natives.collect {
        it.name.endsWith('.zip') ? zipTree(it) : it
    })
}

task scpJar(type: Exec) {
    def user = 'frc302'
    def host = 'dragondataloggerz.local'
    def login = "${user}@${host}"
    def key = project.file('keys/id_ed25519').absolutePath
    def jar = project.file('build/libs/PiLogger-linuxarm64-cross.jar').absolutePath
    commandLine 'scp', '-i', key, jar, "${login}:/tmp/PiLogger-linuxarm64-cross.jar"
}

task scpScript(type: Exec) {
    def user = 'frc302'
    def host = 'dragondataloggerz.local'
    def login = "${user}@${host}"
    def key = project.file('keys/id_ed25519').absolutePath
    def script = project.file('deploy/pi-logger/home/frc302/deploy-pi.sh').absolutePath
    commandLine 'scp', '-i', key, script, "${login}:/home/frc302/deploy-pi.sh"
}

task runDeployScript(type: Exec) {
    def user = 'frc302'
    def host = 'dragondataloggerz.local'
    def login = "${user}@${host}"
    def key = project.file('keys/id_ed25519').absolutePath
    commandLine 'ssh', '-i', key, login, 'chmod +x /home/frc302/deploy-pi.sh && /home/frc302/deploy-pi.sh'
}

scpScript.mustRunAfter scpJar
runDeployScript.mustRunAfter scpScript

task deployPi {
    dependsOn scpJar, scpScript, runDeployScript
    group = 'Deployment'
    description = 'Deploys PiLogger and runs deploy script on the Pi'
}

// Setup Pi SSH key task: creates .ssh directory, copies authorized_keys, sets permissions
task setupPiSSHKey {
    doLast {
        def user = 'frc302'
        def host = 'dragondataloggerz.local'
        def login = "${user}@${host}"
        def authFile = project.file('deploy/pi-logger/home/frc302/.ssh/authorized_keys').absolutePath

        exec {
            commandLine 'ssh', login, 'mkdir -p ~/.ssh && chmod 700 ~/.ssh'
        }
        exec {
            commandLine 'scp', authFile, "${login}:~/.ssh/authorized_keys"
        }
        exec {
            commandLine 'ssh', login, 'chmod 600 ~/.ssh/authorized_keys'
        }
        println 'Pi key setup complete.'
    }
}

// Setup Pi task: checks marker file, copies files, runs remote setup script
task setupPi {
    doLast {
        def user = 'frc302'
        def host = 'dragondataloggerz.local'
        def login = "${user}@${host}"
        def key = project.file('keys/id_ed25519').absolutePath
        def markerCheckFile = '__pi_marker_check.txt'
        def piloggerService = project.file('deploy/pi-logger/etc/systemd/system/pilogger.service').absolutePath
        def setupScript = project.file('deploy/pi-logger/home/frc302/setup-pi.sh').absolutePath

        // Check marker file only; skip setup if present
        def markerCheck = exec {
            commandLine 'ssh', '-i', key, login, 'test -f /home/frc302/this_pi_has_been_setup'
            ignoreExitValue = true
        }

        if (markerCheck.exitValue == 0) {
            println "${host} already setup; aborting."
            return
        } else if (markerCheck.exitValue != 1) {
            println "SSH connection failed or unexpected error (exit code: ${markerCheck.exitValue}). Aborting setup."
            return
        }

        println "Setting up ${host}..."

        // Copy service file
        def result1 = exec {
            commandLine 'scp', '-i', key, piloggerService, "${login}:/tmp/pilogger.service"
            ignoreExitValue = true
        }
        if (result1.exitValue != 0) {
            throw new GradleException("Failed to copy pilogger.service to ${host}. Aborting.")
        }

        // Copy setup script
        def result2 = exec {
            commandLine 'scp', '-i', key, setupScript, "${login}:/home/frc302/setup-pi.sh"
            ignoreExitValue = true
        }
        if (result2.exitValue != 0) {
            throw new GradleException("Failed to copy setup-pi.sh to ${host}. Aborting.")
        }

        // Run setup script remotely
        def result3 = exec {
            commandLine 'ssh', '-i', key, login, 'chmod 755 /home/frc302/setup-pi.sh && sudo /home/frc302/setup-pi.sh'
            ignoreExitValue = true
        }
        if (result3.exitValue != 0) {
            throw new GradleException("Remote setup script failed with error ${result3.exitValue}.")
        }

        println "${host} setup complete."
    }
}

